#!/bin/bash
####################################################
## "Launchy" 
## Script defining a CLI shortcut system for user applications.
## Intended particularly for games requiring emulation or 
## virtualized environments; e.g. DOSBox or WINE.
## 
## Functions differently depending upon value of $0.
## Thus, symbolic links to this script are necessary in order to 
## produce the full range of capability.   
## Expected values of $0:
##  dos                 Handles DOSBox calls 
##  launch, run, play   Handles primary system calls
##
## James McConnel May 19, 2016
##
##TODO Add a method to create aliases and deemphasize .launchrc which maybe just duplicating that feature.


##Constants for launch function
gameindex=~/.launchrc

##Constants for DOS functions
dos_system=dosbox
defaultconf=~/DOS/conf/games.conf
defaultbootconf=~/DOS/conf/boot_MSDOS622.conf
configmodeconf=~/DOS/conf/boot_MSDOS622_config.conf
mt32conf=~/DOS/conf/mt-32.conf

##Constants for WINE functions
bottle=~/.wine

## If running on windows Subsystem for Linux
if grep -q Microsoft /proc/version; then
   dos_system="/mnt/c/Program Files (x86)/DOSBox-0.74-3/DOSBox.exe"
   confeditor=vim
else
   confeditor=gedit
fi

print_wine_help ()
{
   echo "Usage: $(basename "$0") [OPTIONS] [COMMAND]"
   echo "Provides some shortcuts for WINE."
   echo "COMMAND is a valid command in the environment to be loaded."
   echo
   echo "Comes with no warranty."
   echo
   echo "  -b, --bottle Set the bottle to use."
   echo "  -f, --follow Change to directory of program before executing."
   echo "  -h, --help   Print this message and exit."
}

wine_function ()
{
   echo $@
   echo $1
   while [ "$0" ]; do
      case "$1" in
      "")
         if [ "$program" ]; then
            break 
         else
            print_wine_help
            exit
         fi
      ;;
      "-b" | "--bottle")
         echo $2
         ls ~/other_vm/wine-prefixes | grep "$2"
         case "$2" in
         "default")
            bottle=~/.wine
         ;;
         "$(ls ~/other_vm/wine-prefixes | grep "$2")")
            echo hello
            bottle=/home/yehoodig/other_vm/wine-prefixes/$2
         ;;
         *)
            bottle=$2
         ;;
         esac
      ;;
      "-h" | "--help")
         print_wine_help
         exit
      ;; 
      "-f" | "--follow")
         follow=true
      ;;
      *)
         program="$1"
      ;;
      esac
      shift
   done
   (
      echo $bottle
      export WINEPREFIX=$bottle
      if [ $follow ]; then
         cd "$(dirname "$(winepath "$program")")"
      fi
      pwd
      echo $program
      wine "$program"
   ) 
}

##Help Function
print_dos_help () 
{
   echo
   echo "Usage: $(basename "$0") [OPTIONS] [COMMAND]"
   echo "Provides some shortcuts for DOSBox."
   echo "COMMAND is a valid DOS COMMAND in the environment to be loaded."
   echo 
   echo "Comes with no warranty."        
   echo
   echo "OPTIONS:"
   echo "      --mt-32        Uses the MT-32 conf."
   echo "      --boot         Alternate DOSBox session using a full x86 emulation, in a Virtual HDD."
   echo "      --config-mode  Mounts the bootable image in the DOSBox shell."
   echo "  -p, --pass         Pass what follows to DOSBox without modification." 
   echo "      --show         Print out defaults and exit."
   echo "  -h, --help         Print this message and exit."
	echo
   echo "NOTE 1: --boot, --config-mode and --pass are mutually exclusive."
   echo "NOTE 2: --boot environment cannot accept COMMANDS"
}

dos_function ()
{
   #Builds a parameter list to send to DOSBox.  Effectively, just a wrapper so that I don't have to remember my local cofiguration.
   #Note to self: Avoid the temptation to remake the DOSBox command line.
   
   #Parses the options provided to generate a command which is then passed to DOSBox.
   #config is where the DOSBox command is stored 
   if [ "$1" == "--help" -o "$1" == "-h" ]; then
      print_dos_help
      exit
   elif [ -z "$1" ]; then
      config=" -conf $defaultconf"
   elif [ "$1" == "--show" ]; then
      echo Userconf: $("$dos_system" -printconf)
      echo Default:  $defaultconf
      echo Boot:     $defaultbootconf
      echo MT-32:    $mt32conf
      exit
   else
      while [ "$1" ]; do
	 case "$1" in
	 "--mt-32")
	    config+=" -conf $mt32conf"
	 ;;
	 "--config-mode") 
	    if [[ "$config" == *"-conf $defaultbootconf"* ]]; then
	       echo Error: --boot not compatible with --config-mode
	       exit
	    fi
	    config+=" -conf $configmodeconf"
	 ;;
	 "-p" | "--pass")
	    if [[ "$config" == *"-conf $defaultbootconf"* ]]; then
	       echo Warning: Passing does not work in boot mode
	    fi
	    shift
	    pass=$@
	    break
	 ;;
	 "--boot")
	    if [[ "$config" == *"-conf $configmodeconf"* ]]; then
	       echo Error: --config-mode not compatible with booting
	       exit
	    fi
	    config+=" -conf $defaultbootconf"
	 ;;
	 esac
	 shift
      done
      config+=" -conf $defaultconf"
   fi
   ##Output a status message just prior to command execution.
   status="Starting "
   if [ "$pass" ]; then
      status+="$pass in DOSBox with configuration: $config...\n"
   else
      status+="DOSBox with configuration: $config...\n"
   fi

   ##Launch Command
   if [ "$pass" ]; then
      "$dos_system" -userconf $config -c "$pass"
   else
      "$dos_system" -userconf $config 
   fi
}

##Help Function
print_launchy_help () 
{
   echo
   echo "Usage: $(basename "$0") [OPTIONS] [COMMAND]"
   echo "Provides some shortcuts for running commands."
   echo "COMMAND is a valid COMMAND in:"
   echo " ~/.launchrc"
   echo " ~/bin"
   echo " or any valid system command"
   echo 
   echo "Comes with no warranty."        
   echo
   echo "OPTIONS:"
   echo "      --list         Prints a list of available commands (excluding system commands)."
   echo "  -h, --help         Print this message and exit."
}

launchy_function ()
{
   ## Just a little script to make it easier to launch miscellaneous stuff.
   ## Effectively, all it does is run commands defined in ~/.launchrc or ~/bin.
   ## 
   if [ -z "$1" -o "$1" == "--help" -o "$1" == "-h" ]; then
      print_launchy_help
      exit
   elif [ "$1" == "--list" ]; then
      echo $(tput bold)$gameindex shortcuts:$(tput sgr0)
      while read line; do
         if [[ "$line" == *"="* ]]; then
            echo ${line%=*}
         fi
      done <<< "$(cat $gameindex)"
      echo 
      echo $(tput bold)User scripts:$(tput sgr0)
      ls --format=single-column ~/bin
      exit
   else 
      gameline="$(grep "$1=" $gameindex)"
      command=${gameline#$1=} #This removes "$1=" from the front of the string.
   fi

   if [ -n "$command" -a "$command" != "$gameline" ]; then # If the key was given and is valid
      echo Index entry: $gameline
      echo Parsed Command: $command
      eval "$command"
   elif [ "$(ls ~/bin | grep $1 2>/dev/null)" ]; then # If instead the key is the name of something in ~/bin
      echo bin command: $1
      ~/bin/$@
   elif [ -n "$1" ] && type $1 >/dev/null; then
      echo System command: \"$1\" found.  Shall I launch it? [y/n]
      read ans
      if [ "$ans" == "y" ]; then
         $@
      fi
   else 
      echo Application not found.
      echo Please check your spelling, or try enclosing the name in quotes.
      echo Also see the index file: $gameindex 
   fi
}

bundle_function()
{
   mainline="$(grep "main=" $1/.launchy)"
   main=${mainline#main=}
   main=$(dirname $1/$main)/$main
   $main
}


##
case $(basename $0) in
   "dos" | "386" | "486" | "pentium" | "cga" | "vga" | "msdos")
      dos_function "$@"
      exit
   ;;
   "launch" | "launchy" | "launcher" | "run" | "start" | "play")
      if [ -n "$1" -a -d "$1" ]; then
         if [ -e $1/.launchy ]; then
            bundle_function "$@"
         else
            echo "\"$@\""
            echo Error: parameter is directory
         fi
      else
         launchy_function "$@"
      fi
      exit
   ;;
   "win" | "wino" | "winey" | "winer" | "windoze" | "win16" | "win32" | "win64")
      wine_function "$@"
      exit
   ;;
   *)
      echo "Insert Easter Egg here"
      exit
   ;;
esac
